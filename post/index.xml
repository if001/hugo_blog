<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on アンドロイドは推理小説を描くか?</title>
    <link>https://if001.github.io/hugo_blog/public/post/</link>
    <description>Recent content in Posts on アンドロイドは推理小説を描くか?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 01 Mar 2019 20:48:42 +0900</lastBuildDate>
    <atom:link href="/hugo_blog/public/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>pythonで拡張子を取得する</title>
      <link>https://if001.github.io/hugo_blog/public/post/python-get-extn/</link>
      <pubDate>Fri, 01 Mar 2019 20:48:42 +0900</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/python-get-extn/</guid>
      <description>ファイルの拡張子を取得する方法をいつも忘れるのでメモ
import os file_path = &amp;#34;hoge/test.md&amp;#34; root, ext = os.path.splitext(file_path) print(root, ext) 出力
hoge/test .md  </description>
    </item>
    
    <item>
      <title>falconでアップロードサーバーを作る</title>
      <link>https://if001.github.io/hugo_blog/public/post/falcon/falcon-img-upload/</link>
      <pubDate>Tue, 16 Oct 2018 20:48:42 +0900</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/falcon/falcon-img-upload/</guid>
      <description>はじめに 現在、サーバー上にHugoとHugoが生成した静的ファイルを置いてブログを公開している。 静的ファイルの生成とmdファイルや画像ファイルのアップロードのためfalconを使ってapiサーバーを作った。 falconをつかったのは、flaskやbottleは使ったことあったので、使ったことないものをということで。
クライアント クライアントにはpythonのrequestsを使います。
fileにタプルでファイル名を明示的に渡せる。 postの引数にfilesで渡すと、contents-typeもよしなにしてくれるんですね。
image_name = &amp;#34;test.png&amp;#34; with open(image_file_path, &amp;#34;rb&amp;#34;) as image: files = {&amp;#39;file&amp;#39;: (image_name, image)} response = requests.post(url, files=files) print(response.text) サーバー falconはコンテナ上で動かします。ファイルアップロードのリクエストを受けると、 サーバー上のストレージに画像を保存します。
なんかできないと思ってたら、middlewareにMultipartMiddlewareを指定しないとだめだった。
fileは次のようにrequestから取得できる
image = req.get_param(&amp;#39;file&amp;#39;) raw = image.file.read() ファイル名は次のように取得
image_name = image.filename  実際は、corsとかあるがそれを省いた、アップロードだけの全体は以下のようになる。
from falcon_multipart.middleware import MultipartMiddleware import falcon import json class UploadImage(object): def on_post(self, req, resp): image = req.get_param(&amp;#39;file&amp;#39;) raw = image.file.read() image_name = image.filename filepath = os.path.join(BASE_DIR, &amp;#34;static&amp;#34;, image_name) try: with open(filepath, &amp;#39;wb&amp;#39;) as f: f.</description>
    </item>
    
    <item>
      <title>Deeplearningまわりの最新論文を浅く広くみてまわる</title>
      <link>https://if001.github.io/hugo_blog/public/post/neuralnet/pepar_summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/neuralnet/pepar_summary/</guid>
      <description>最新論文の情報を広く浅く集めたい場合の巡回するサイトたちをまとめておきます。
おすすめがあれば教えてください。
Google Scholar: https://scholar.google.com/schhp?hl=ja
研究者やキーワードが決まっていると探しやすい。ただ、ザッピングには向かない。
いろいろ論文の検索エンジン使ってたけど、結局これが残った。texの引用が楽
arXiv arXiv https://arxiv.org/
トップページは慣れないとちょっと見づらい。有名な研究者で検索したものや分野で絞り込んだものをチェックするのが使いやすそう。
arXivTimes https://medium.com/@arxivtimes
日本語、arXivのまとめ系、ツイッター
論文まとめてくれてるGitHub https://github.com/dennybritz/deeplearning-papernotes
arXivのまとめ。古いものは2011年から、新しいものは2018まで更新がある。
企業の論文 DeepMind https://deepmind.com/research/publications/
Microsoft Research Publications http://research.microsoft.com/apps/catalog/default.aspx?t=publications&amp;amp;ra=47200
Google Research Publications http://research.google.com/pubs/ArtificialIntelligenceandMachineLearning.html
Yahoo! Labs http://labs.yahoo.com/publication/?area=machine-learning</description>
    </item>
    
    <item>
      <title>GoogleAnalyticsのPV、セッション、ユーザーの定義</title>
      <link>https://if001.github.io/hugo_blog/public/post/others/ga-define/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/others/ga-define/</guid>
      <description> ユーザー PV:ページ毎に閲覧された回数 セッション：30分以上の間隔をあけた操作、日付またぎ、別の参照元 ユーザー：cookieで保持
GDPRにより以下のものから保持期間を選択できる
 14 か月 26 か月(デフォルト) 38 か月 50 か月 自動的に期限切れにならない  集客 行動 コンバージョン </description>
    </item>
    
    <item>
      <title>Hugoでブログを作る</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/hugo-start-article/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/hugo-start-article/</guid>
      <description>はじめに Hugoとは、go言語で書かれた、静的なwebサイトをbuildingするためのframeworkです。 Hugoを使ってブログを作ってみたので構築方法を簡単にまとめておきます。
サイトの作成 インストール brew install hugo  テンプレートの作成 hugo new site hugo-test  これで、次のようにテンプレートが作成されます。
$ ls hugo-test/ archetypes/ config.toml content/ data/ layouts/ static/ themes/  テーマの適応 https://themes.gohugo.io/ ここからテーマを探す。
例として、https://themes.gohugo.io/hugo-theme-learn/ を使います。
$ cd hugo-test/themes $ git clone https://github.com/matcornic/hugo-theme-learn.git  テーマを適応させるために、config.tomlにthemeを記述します。
theme = &amp;quot;hugo-theme-learn&amp;quot;  サーバーの起動 $ hugo server -D -t hugo-theme-learn  オプションDでDraftフラグのついた記事の確認、オプションtでテーマの適応です。 cloneしてきたtheme内の、layoutとstaticなどを、作成したテンプレート内のlayout、staticに移動しておくと、templateのマイナーチェンジが行えます。
デフォルトでhttp://localhost:1313/で起動するのでアクセスしてみる。
記事の追加 記事の作成
$ hugo new post/test.md hugo_test/content/post/test.md created  以下のようなmarkdownファイルが作成される
cat content/post/test.md --- title: &amp;quot;Test&amp;quot; date: 2018-10-15T18:51:47+09:00 draft: true ---  ここで、draftは記事を後悔するかのフラグ この出力フォーマットも、独自に設定が可能</description>
    </item>
    
    <item>
      <title>Hugoでリンクを新しいウィンドウで開く</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/hugo-href-to-target-blank/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/hugo-href-to-target-blank/</guid>
      <description>リンクは新しいウィンドウで開いて欲しい派なんだけど、Hugoではデフォルトで通常のリンクの開きかた(?)をする。
hrefではtarget=&#39;_blank&#39;を指定すれば良いのだが、markdownでどうすれば良いのか調べた。 Hugoでは次のようにconfig.tomlするといける。
[blackfriday] hrefTargetBlank = true 簡単！
参考：
 https://gohugo.io/getting-started/configuration/ https://www.meganii.com/blog/2017/02/25/hugo-markdown-href-target-blank/  </description>
    </item>
    
    <item>
      <title>Hugoで作ったwebサイトを公開する</title>
      <link>https://if001.github.io/hugo_blog/public/post/others/http-portal-for-blog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/others/http-portal-for-blog/</guid>
      <description>はじめに GCE上にdockerコンテナを使って、hugoの静的ファイルを公開してます。
いろいろwebサービスを作ったりはしますが、公開するのは初めてだったので、いろいろと苦労した点をまとめておきます。
インフラ GCEを使います。ほんとは、image化してインスタンスグループで公開したかったのですが、とりあえず、コンテナをVM上にデプロイすることにします。
ドメイン ドメインは、お名前.comで取得します。これは特に説明なしでいけます。
DNSは、route53を使いたかったんですが、今回はgoogleのcloud DNSを使います。
Google Cloud Consoleから、「ネットワークサービス」→「Cloud DNS」を選択します。
任意のゾーン名、取得したドメイン、(説明)を入力して作成。
  Aレコードの登録 DNS名には、www.取得したドメイン、リソースタイプにはAレコードを設定し、作成します。   レジストラへの登録 生成されるNSレコードのns-cloud-c1.googledomains.com.をお名前.com側に登録します。
https化 let&amp;rsquo;s encryptを使ってhttps化しようと思っていたところ便利なものを発見したのでこちらを使います。
https-portal
自動で証明書の更新も行ってくれます。すごい。便利。
親切にdocker-composeが公式に載せてあるので、参考にします。 docker-composeのインストールはpipなどで行ってください。
https-portal:image:steveltn/https-portal:1ports:-&amp;#39;80:80&amp;#39;-&amp;#39;443:443&amp;#39;links:-wordpressrestart:alwaysenvironment:DOMAINS:&amp;#39;wordpress.example.com -&amp;gt; http://wordpress:80&amp;#39;# STAGE: &amp;#39;production&amp;#39;# FORCE_RENEW: &amp;#39;true&amp;#39;wordpress:image:wordpresslinks:-db:mysqldb:image:mariadbenvironment:MYSQL_ROOT_PASSWORD:&amp;#39;&amp;lt;a secure password&amp;gt;&amp;#39; imageのバージョンは:1と指定しましょう。最新版を取ってくるようになります。
image: steveltn/https-portal:1  1.2以下だと、let&amp;rsquo;s Encryptで証明書を取得する際にエラーが起きるので注意です。
links:-wordpress linksで公開するサービス名を指定しましょう。
environment:DOMAINS:&amp;#39;wordpress.example.com -&amp;gt; http://wordpress:80&amp;#39; 環境変数のDMAINSでは、リクエストを受けるドメイン -&amp;gt; https化したいエンドポイントを指定します。
linksで指定したエイリアスで指定できます。また、-&amp;gt;を=&amp;gt;に変更することでリダイレクトができます。
STAGEは、次の3つが指定できます。
 STAGE: &#39;local&#39;でオレオレ証明書を作成します。テストなどに STAGE: &#39;staging&#39;でテスト用の証明書を作成します。 STAGE: &#39;production&#39;で本番用に、Let&amp;rsquo;s Encryptで正式な証明書を作成します。  その他、環境変数も指定できます。この辺りを参考しながら、設定を行います。 https://github.com/SteveLTN/https-portal/tree/master/fs_overlay/var/lib/nginx-conf</description>
    </item>
    
    <item>
      <title>Hugoにgoogle analyticsを導入する</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/hugo-ga/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/hugo-ga/</guid>
      <description>Hugoにgoogle analytics(ga)を導入しようと思ったら意外と簡単だった。
まず、gaアカウントを作成。
config.tomlに
googleAnalytics = &amp;quot;{ga tracking ID}&amp;quot;  を設定するだけ。</description>
    </item>
    
    <item>
      <title>Hugoの記事にdescriptionを追加する</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/hugo-add-site-description/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/hugo-add-site-description/</guid>
      <description>Hugoで書いた記事が検索で引っかからないなと思っていたら、descriptionタグが設定されていませんでした。 これでは検索に引っかからないのでdescriptionタグをつけましょう!
html側で次のように書くと、markdownに書いたdescriptionが参照できます。
{{ .Description }} markdown側では、ヘッダーに次のように記述します。
description=&amp;quot;hogehoge&amp;quot;  これまで書いた記事全てに、descriptionをつけていくのは面倒ですね。
次のようにサイトサマリーを参照することも可能です
{{ .Summary }} ただし、デフォルトでサマリーが大きくなりすぎるので、config.tomlに次のような記述を追加します。
hasCJKLanguage=true こうすることでサマリーがいい感じのサイズになります。
参考：https://blog.awm.jp/2016/01/02/hugo/
最終的に、header.htmlなどに次のように記述しておけば、descriptionを書いておくとそちらが使われるようになります。
{{ if .Description }} &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;{{ .Description }}&amp;#34;&amp;gt; {{ else }} &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;{{ .Summary }}&amp;#34;&amp;gt; {{ end }} サイトのディスクリプションと記事のディスクリプションを分ける(追記) {{ if .IsHome }}でトップページかどうか判定できるので、トップページならば、configのディスクリプションを使い、記事内ならば記事に設定してあるディスクリプションを使う。
html側は次のように記述する。
{{ if .IsHome }} {{ with .Site.Params.description }} &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;{{ . }}&amp;#34;&amp;gt; {{ end }} {{ end }} {{ if .Description }} &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;{{ .</description>
    </item>
    
    <item>
      <title>Hugoの記事に画像を載せる</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/hugo_on_image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/hugo_on_image/</guid>
      <description>Hugoに画像を載せるときは、shortcodesを使うと良いらしい。
画像の場合は、static/media以下に画像ファイルが置いてある状態で、次のように書く。
\{{&amp;lt; figure src=&amp;quot;/media/spf13.jpg&amp;quot; title=&amp;quot;Steve Francia&amp;quot; width=&amp;quot;320&amp;quot; height=&amp;quot;640&amp;quot; &amp;gt;}}  画像のサイズも指定可能。
ここでは、shortcodesをエスケープさせるために、/*を使っている。
{{&amp;lt; code &amp;gt;}}  すると、次のようなHTMLが出力される。
&amp;lt;figure&amp;gt; &amp;lt;img src=&amp;quot;/media/spf13.jpg&amp;quot; /&amp;gt; &amp;lt;figcaption&amp;gt; &amp;lt;h4&amp;gt;Steve Francia&amp;lt;/h4&amp;gt; &amp;lt;/figcaption&amp;gt; &amp;lt;/figure&amp;gt;  </description>
    </item>
    
    <item>
      <title>KaTeXを使ってみる</title>
      <link>https://if001.github.io/hugo_blog/public/post/hugo/katex-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/hugo/katex-introduction/</guid>
      <description>これまでMathJaxを使っていたが、描画が遅いということもあり、$\KaTeX$を使ってみることにしました。 KaTeX:https://katex.org/
以下を加えるだけでおk
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css&amp;#34; /&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;$(document).ready(function(){renderMathInElement(document.body,{delimiters: [{left: &amp;#34;[[&amp;#34;, right: &amp;#34;]]&amp;#34;, display: true},{left: &amp;#34;$&amp;#34;, right: &amp;#34;$&amp;#34;, display: false}]})});&amp;lt;/script&amp;gt; MathJaxで表示していた数式も無事表示されてとりあえず問題なしです。 実際に入れてみた感じやっぱり早い。
参考 KaTeXによる数式の表示:https://sekika.github.io/2017/05/01/katex-equation/ KaTeXを導入しました:http://nshi.jp/contents/other/katex/ KaTeXのデモ:http://sixthform.info/katex/examples/demo.html</description>
    </item>
    
    <item>
      <title>Rustでmodule間にまたがるmacro呼び出し</title>
      <link>https://if001.github.io/hugo_blog/public/post/others/rust-macro-use-another/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/others/rust-macro-use-another/</guid>
      <description>Rustのmacroをモジュール化して、別のモジュールから呼ぼうと思ったらうまくいかなかった。
日本語の記事があまりなかったのと、自分の備忘録ようにメモを残しておく。
rustのバージョンは1.27.0
参考 https://github.com/rust-lang/book/issues/401
マクロの書き方とか、rustのimport周りは意外と日本語記事があったので、そっちを参考に
ファイル構成 lib.rsでmodをまとめて、main.rsで呼ぶようなファイル構成にする。 このようにしておくと、main.rsのなかでmodを宣言しなくてよくなるし、また誰が誰を公開しているかわかりやすくなる（たぶん）。
crate/ src/ main.rs lib.rs mod1/ mod.rs macro.rs mod2/ mod.rs macro_run.rs  この時、main.rsを実行すると、macro_run.rsの中の関数が呼ばれ、この関数内でmacro.rsに定義してあるマクロが呼び出されるとする。
簡単に言うと、モジュール間に跨ったマクロ呼び出しが行いたい。
書き方 main.rsでは、macro_run内にあるrun関数を呼ぶ。
// main.rs externcraterust_test2;userust_test2::mod2::macro_run;fn main(){macro_run::run();} run関数内では、foo!というマクロを使う。
// macro_run.rs #[macro_use]usemod1::macro_test::*;pubfn run(){letfoo=foo!(1);println!(&amp;#34;{}&amp;#34;,foo);} fooマクロは、引数をそのまま返す単純なマクロ。
// macro.rs #[macro_use]macro_rules!foo{($e: expr)=&amp;gt;{$e}} macro_useをつける。
// mod1/lib.rs #[macro_use]pubmod macro_test; ここのlibにもmacro_useが必要。
// lib.rs #[macro_use]pubmod mod1;pubmod mod2; 次のように#[macro use]の順番が入れ変わるとだめ (参考：https://www.ncameron.org/blog/macros-in-rust-pt4/)
// lib.rs pubmod mod2;#[macro_use]pubmod mod1; まとめ  #[macro_use]をいっぱいかく lib.rsに書く順番が大切 コードの一部はネットの情報としてあったが、コードの全体がわからずハマったので全体をgithubにあげておく  https://github.com/if001/rust_macro_test</description>
    </item>
    
    <item>
      <title>SeqGANの論文を読む</title>
      <link>https://if001.github.io/hugo_blog/public/post/nlp/seqgan-paper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/nlp/seqgan-paper/</guid>
      <description>SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient
https://arxiv.org/pdf/1609.05473.pdf
SeqGANの論文を読んだのでまとめておきます。実装を行おうと思って読んだので手法をメインに読みます。 結果などは余力があれば加筆します。
はじめに 文章生成では、LSTMcellを使ったRNNが優れたパフォーマンスを行う。一般的な学習法は対数尤度を最大化する方法だが、次のような問題点がある。
 exposure bias(予測時には、自分の出力から次の語を予測することによるbias) BLEUを使っても良いけど、詩やchatbotだと難しい  これらの問題に対して、General adversarial net(GAN)が有効そうである。ただし2つの問題がある。
 GANは連続データを生成するように設計されており、sequenceなどの離散データを直接生成するのは難しい。生成モデルGのパラメータの更新に識別モデルDの勾配を用いているが、微小な勾配により更新された生成モデルGに対応する出力値が離散のため存在しない可能性があるためである。 GANは、生成された文全体に対して、score/lossのみを与えることができる。部分的に生成されたsequenceには、文全体としての現在と将来のscoreのバランスをどのようにうまく取れば良いかが自明でない。  そこで、生成モデルに強化学習を用いたGANであるSeqGANを提案する。
Sequence Generative Adversarial Nets 生成モデル$G_ \theta $はパラメータを$\theta$として、$Y_ {1:T} = (y_ 1, y_ 2 , y_ T)$,$y_ t \in \mathcal Y$ を生成するために学習する。ここで、$\mathcal Y$はvocabularyを表す。
学習には、強化学習を用いる。時刻$t$において、状態$s$は現在の単語列$(y_ {1},y_ {2}, \ldots ,y_ {t-1})$を表し、行動$a$により次の単語$y_ t$を選択する。このため、方策モデル$G_ {\theta} (y_ {t}|Y_ {1:t-1})$ は確率的である。一方、行動を選択したあとでは、状態遷移は決定的である。つまり、もし現在の状態が$s=Y_ {1:t-1}$で行動が$a=y_ {t}$ならば、次の状態$s&amp;rsquo;=Y_ {1:t}$に対して、$\delta^a_ {s,s&amp;rsquo;}=1$である。そうでないなら、次の状態$s&amp;rdquo;$に対して$\delta^a_ {s,s&amp;rdquo;}=0$である。
加えて、パラメーター$\phi$を持つ識別モデル$D_ \phi$は、生成モデル$G_ \theta$を学習しながら正解を識別する。識別モデル$D_ \phi$は、本物の文章かどうかを確率的に識別する。</description>
    </item>
    
    <item>
      <title>falconを使ってみた</title>
      <link>https://if001.github.io/hugo_blog/public/post/falcon/falcon-tips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/falcon/falcon-tips/</guid>
      <description>はじめに Hugoをおいているwebサーバーに画像や、mdファイルをアップロードするためのapiサーバーとしてfalconを使ってみた。ORMなど必要なく、簡単なアップロードができれば良いということで、軽量さとシンプルさが特徴のfalconを使う。
簡単なtipsをメモしておく。
シンプルな例 falconの公式に乗っているように、シンプルな例は次のようになる。
# sample.py import falcon class QuoteResource: def on_get(self, req, resp): &amp;#34;&amp;#34;&amp;#34;Handles GET requests&amp;#34;&amp;#34;&amp;#34; quote = { &amp;#39;quote&amp;#39;: ( &amp;#34;I&amp;#39;ve always been more interested in &amp;#34; &amp;#34;the future than in the past.&amp;#34; ), &amp;#39;author&amp;#39;: &amp;#39;Grace Hopper&amp;#39; } resp.media = quote api = falcon.API() api.add_route(&amp;#39;/quote&amp;#39;, QuoteResource()) 処理シーケンス falconにはmiddlewareの他に、hooksというものが使える。 hooksを含めた処理シーケンスは次のようになる。
Middleware&#39;s process_request Middleware&#39;s process_resource Hook&#39;s before Resource&#39;s on_**** Hook&#39;s after Middleware&#39;s process_response  引用：https://qiita.com/yohjizzz/items/f46bb3bc7b7c40768836
middlewareを使った、認証系の共通処理はよく見るが、hookが使えるのは良いですね。
hooks hooksは以下のように使う。(公式)</description>
    </item>
    
    <item>
      <title>kerasでモデルを結合する</title>
      <link>https://if001.github.io/hugo_blog/public/post/neuralnet/combine_model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://if001.github.io/hugo_blog/public/post/neuralnet/combine_model/</guid>
      <description>autoencoderなどを作っていると、保存や推論を行う上での再利用性を考え、encoderとdecoderは分けてModelを作りたいことがある。
autoencoderの学習の際には、作成したencoderのModelとdecoderのModelを結合する。
Modelの結合は前はできなかった気がするが、できるようになっていたのでメモ。
Kerasのバージョンは、2.1.1
まずは、シンプルなモデルを2つ作る。input→model1→model2→outputを作る。
def model1(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model def model2(): layer_input = Input(shape=(None, 10)) layer_output = Dense(10)(layer_input) model = Model(layer_input, layer_output) model.summary() return model まず、model1へのインプットを作る。model1のアウトプットをmodel2のインプットにし、Modelのインスタンスを作る。
m1 = model1() m2 = model2() inp = Input(shape=(None, 10)) model1_output = m1(inp) out = m2(model1_output) model = Model(inp, out) model.summary() すると、こんな感じでモデルが結合できたのが確認できる。
Using TensorFlow backend. _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_1 (InputLayer) (None, None, 10) 0 _________________________________________________________________ dense_1 (Dense) (None, None, 10) 110 ================================================================= Total params: 110 Trainable params: 110 Non-trainable params: 0 _________________________________________________________________ _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_2 (InputLayer) (None, None, 10) 0 _________________________________________________________________ dense_2 (Dense) (None, None, 10) 110 ================================================================= Total params: 110 Trainable params: 110 Non-trainable params: 0 _________________________________________________________________ _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= input_3 (InputLayer) (None, None, 10) 0 _________________________________________________________________ model_1 (Model) (None, None, 10) 110 _________________________________________________________________ model_2 (Model) (None, None, 10) 110 ================================================================= Total params: 220 Trainable params: 220 Non-trainable params: 0 _________________________________________________________________ コード全体はこんな感じ。</description>
    </item>
    
  </channel>
</rss>
